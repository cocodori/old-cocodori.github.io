<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>murmur</title>
 <link href="https://cocodori.github.io/atom.xml" rel="self"/>
 <link href="https://cocodori.github.io/"/>
 <updated>2022-02-26T15:06:44+01:00</updated>
 <id>https://cocodori.github.io</id>
 <author>
   <name>Hoon</name>
   <email>leejihun1024@gmail.coms</email>
 </author>

 
 <entry>
   <title>코틀린 프로퍼티</title>
   <link href="https://cocodori.github.io/2022/02/26/effective-kotlin-item-16-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4"/>
   <updated>2022-02-26T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/26/effective-kotlin-item-16-프로퍼티는-동작이-아닌-상태를-나타내야-한다</id>
   <content type="html">&lt;p&gt;코틀린 프로퍼티는 자바 필드와 비슷하게 보이지만 다른 개념이다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//kotlin property&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Java field&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;둘 다 데이터를 저장한다는 점은 같지만 프로퍼티에는 더 많은 기능이 있다. 기본적으로 프로퍼티는 사용자 정의 세터와 게터를 가질 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isNullOrBlank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;field&lt;/code&gt; 라느 식별자를 확인할 수 있다. 이는 프로퍼티의 데이터를 저장해두는 backing field에 대한 레퍼런스다. 이런 백킹 필드는 세터, 게터의 디폴트 구현에 사용되므로 따로 만들지 않아도 디폴트로 생성된다.&lt;/p&gt;

&lt;p&gt;참고로 val을 사용해서 읽기 전용 프로퍼티를 만들 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;field&lt;/code&gt;가 만들어지지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fullName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$name $surname&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;var을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있다. 이런 프로퍼티를 파생 프로퍼티(derived property)라고 부르며 자주 사용한다.&lt;/p&gt;

&lt;p&gt;이처럼 코틀리느이 모든 프로퍼티는 디폴트로 캡슐화되어 있다. 예를 들어 자바 표준 라이브러리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Date&lt;/code&gt; 를 활용해 객체에 날짜를 저장해서 많이 활용한 상황을 가정해본다. 프로젝트를 진행하는 중에 직렬화 문제 등으로 객체를 더 이상 이런 타입으로 저장할 수 없게 되었는데, 이미 프로젝트 전체에서 이 프로퍼티를 많이 참조하고 있다면 어떻게 해야 할까? 코틀린은 데이터를 millis라는 별도의 프로퍼티로 옮기고, 이를 활용해서 date 프로퍼티에 데이터를 저장하지 않고 wrap/unwrap하도록 코드를 변경하기만 하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;millis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;millis&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로퍼티는 필드가 필요 없다. 오히려 프로퍼티는 개념적으로 접근자(val의 경우 게터, var의 경우 게터와 세터)를 나타낸다. 따라서 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pesrson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 코드를 작성하면 이는 게터를 가질 거라는 것을 나타낸다. 따라서 다음과 같이 오버라이드 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Supercomputer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;thenAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppleComputer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Supercomputer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;thenAnswer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1_800_275_2273&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로퍼티는 본질적으로 함수다. 따라서 확장 프로퍼티를 만들 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preferences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharedPreferences&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PreferencesManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getDefaultPreferences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로퍼티는 필드가 아니라 접근자를 나타낸다. 이처럼 프로퍼티를 함수 대신 사용할 수 있지만 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다. 다음처럼 알고리즘의 동작을 나타내는 것은 좋지 않다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;Tree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
						&lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기에서 sum 프로퍼티는 모든 요소를 반복처리하므로, 알고리즘 동작을 나타낸다고 할 수 있다. 이런 프로퍼티는 여러 가지 오해를 불러일으킬 수 있다. 큰 컬렉션의 경우 답을 찾을 때 많은 계산량이 필요하다. 하지만 관습적으로 이런 게터에 그런 계산량이 필요하다고 예상하지 않는다. 따라서 이런 처리는 프로퍼티가 아니라 함수로 구현해야 한다.&lt;/p&gt;

&lt;p&gt;원칙적으로 프로퍼티는 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 게 좋다. 다른 로직을 포함하지 말아야 한다. 어떤 것을 프로퍼티로 해야 하는지 판단할 수 있는 간단한 질문이 있다. ‘이 프로퍼티를 함수로 정의할 경우 접두사로 get 또는 set을 붙일 것인가?’ 만약 아니라면 함수로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;프로퍼티 대신 함수를 사용하는 것이 좋은 경우를 구체적으로 보면 이렇다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연산 비용이 높거나 복잡도가 큰 경우&lt;/li&gt;
  &lt;li&gt;비즈니스 로직을 포함하는 경우&lt;/li&gt;
  &lt;li&gt;결정적이지 않은 경우 → 같은 동작에서 다른 값이 나올 수 있는 경우&lt;/li&gt;
  &lt;li&gt;변환의 경우. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int.toDouble()&lt;/code&gt;과 같은 변환 함수로 이루어진다. 따라서 이런 변환을 프로퍼티로 만들면 오해할 수 있다.&lt;/li&gt;
  &lt;li&gt;게터에서 프로퍼티 상태 변경이 일어나야 하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;반대로 상태를 추출/설정할 때는 프로퍼티를 사용해야 한다. 특별한 이유가 없다면 함수를 사용하면 안 된다.&lt;/p&gt;

&lt;p&gt;많은 경우 경험적으로 프로퍼티는 상태 집합을, 함수는 행동을 나타낸다고 생각한다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>요약 외부 시스템 장애에 대처하는 우리의 자세</title>
   <link href="https://cocodori.github.io/2022/02/25/%EC%9A%94%EC%95%BD-%EC%99%B8%EB%B6%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%A5%EC%95%A0-%EB%8C%80%EC%B2%98"/>
   <updated>2022-02-25T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/25/요약:-외부-시스템-장애-대처</id>
   <content type="html">&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[외부 시스템 장애에 대처하는 우리의 자세&lt;/td&gt;
      &lt;td&gt;우아한형제들 기술블로그](https://techblog.woowahan.com/6447/?fbclid=IwAR1NJ49V0a6EdLdMOnj-nVXQY49WKQu_uNAe3SyrZgGl9oGce2H6ocHwWYg)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 글을 읽고 요약한 글입니다.&lt;/p&gt;

&lt;h2 id=&quot;외수-시스템이랑-왜-연동하나&quot;&gt;외수 시스템이랑 왜 연동하나?&lt;/h2&gt;

&lt;p&gt;필요한 모든 기능을 직접 개발/관리할 수 없음. 그래서 지도, PG, 메시지 서비스 등 외부 시스템을 도움을 받을 수밖에 없다.&lt;/p&gt;

&lt;p&gt;간단한 연동 작업을 통해 수준 높은 서비스를 이용할 수 있고, 직접 구축/운영하는 것보다 비용이 훨씬 적게 듦.&lt;/p&gt;

&lt;p&gt;이 글은 안정적인 서비스 제공을 위해서 어떻게 외부 시스템을 연동하는지 고민을 담은 글&lt;/p&gt;

&lt;p&gt;2018년에 배민이 사용하던 클라우드 서비스가 장애를 일으켰음. 클라우드 서비스 업체의 정상화되었다는 말을 기다리는 것말고는 할 수 있는 게 없었음. 하지만 클라우드 서비스 장애로 대부분 서비스가 동작하지 않았지만, 배민앱은 오프라인 모드 덕분에 스마트폰에 저장된 캐시를 통해서 일부 서비스를 이용할 수 있었음.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;오프라인 모드에 대한 글은 &lt;a href=&quot;https://techblog.woowahan.com/2589/&quot;&gt;여기&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;아무튼 간 이뿐만 아니라 IDC가 죽는 일도 있고 외부 SDK 장애, 통신사 라우팅 장애 등 외부 시스템 장애는 손 쓸 방법도 없기 때문에 고통스러웠음. 배민 2021년 내부 지표에 따르면 발생한 장애 중 45% 이상이 외부 시스템 영향을 받음.&lt;/p&gt;

&lt;p&gt;이 문제를 어떻게 해결할까 고민하면서 2020년부터 &lt;strong&gt;외부 시스템 의존성 조사&lt;/strong&gt;를 시작했음.&lt;/p&gt;

&lt;p&gt;어떤 항목을 수집하냐면
&lt;strong&gt;외부 시스템 정보&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명칭&lt;/li&gt;
  &lt;li&gt;제공 업체 정보&lt;/li&gt;
  &lt;li&gt;2020년 장애 발생횟수&lt;/li&gt;
  &lt;li&gt;사용 보편성&lt;/li&gt;
  &lt;li&gt;갱신 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;내부 서비스 정보&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;담당팀&lt;/li&gt;
  &lt;li&gt;유발 장애 등급&lt;/li&gt;
  &lt;li&gt;알람 채널&lt;/li&gt;
  &lt;li&gt;모니터링 수단&lt;/li&gt;
  &lt;li&gt;로그 정보&lt;/li&gt;
  &lt;li&gt;의존성 약화 or  제거 방안&lt;/li&gt;
  &lt;li&gt;현재 상태&lt;/li&gt;
  &lt;li&gt;목표 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 조사를 통해 리스크를 가시화했음&lt;/p&gt;

&lt;h2 id=&quot;외부-시스템-연동-시-주의사항&quot;&gt;외부 시스템 연동 시 주의사항&lt;/h2&gt;

&lt;p&gt;외부 시스템 문제로 장애가 발생해도 고객은 모름. 우리 앱에 대한 부정적인 경험을 만들 수 있음.&lt;/p&gt;

&lt;p&gt;그래서 외부 시스템 장애를 회피할 수 있는 몇 가지 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;의존성 제거&lt;/p&gt;

    &lt;p&gt;연동이 필요할 때 정말 이 연동이 필요한지 고민해야 함. 연동된 서비스 장애가 우리 서비스에 영향을 주는 경우 필요한 기능이 서비스 안정성보다 우선하는지 비교/판단해야 함. 리스크를 감수할 수 있을 만큼 필요한 기능인가?를 반드시 생각해야 함. 대체할 방법이 있다면 의존관계를 맺지 않는 것이 서비스 안정성을 높이는 가장 쉬운 방법임.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;벤더 이중화&lt;/p&gt;

    &lt;p&gt;PG서비스, 지도 서비스, 문자 서비스 등 벤더 이중화에 적합한 케이스임. 일반적으로 필수 기능은 동일하게 제공하기 때문에 이중화 구현이 가능. 벤더 이중화를 구현할 때는 자동으로 전환되게 하는 것이 가장 좋지만, 현실적으로 불가능한 경우가 많기 때문에 장애 시간을 최소화할 수 있도록 벤더 간 전환이 간단하게 동작할 수 있게 구성하는 것이 중요.&lt;/p&gt;

    &lt;p&gt;개발자가 반드시 개입해야 하는 구조보다, 어드민에 전환 기능을 구현해두고 권한이 있는 다수 팀원이 조치할 수 있도록 구성하는 것이 일반적&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;장애 격리&lt;/p&gt;

    &lt;p&gt;외부 시스템 연동을 하다 보면 이중화를 고려할 만큼 서비스가 크지 않거나, 이중화에 비용이 너무 많이 들거나, 이중화 할 수 있는 다른 벤더가 없는 경우 등 여러 이유로 이중화가 불가능한 시스템도 존재함. 이런 경우 외부 시스템의 장애가 &lt;strong&gt;연동과 관련 없는 부분으로 전파되지 않도록 장애를 격리&lt;/strong&gt;하는 것이 중요. 특정 기능에 장애가 발생하더라도 다른 기능을 사용자가 사용할 수 있도록 제공하는 것이 핵심임.&lt;/p&gt;

    &lt;p&gt;예를 들어 포장 서비스에서 가게 위치를 표시해주는 지도가 있음. 이 지도에 장애가 발생해도 포장 서비스는 이용할 수 있어야 함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;미작동 감내&lt;/p&gt;

    &lt;p&gt;아무리 피해도 회피가 불가능할 때가 있음. 클라우드 서비스가 그럼. 이런 경우 외부 시스템의 장애를 감내해야함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>의도를 드러내는 인터페이스</title>
   <link href="https://cocodori.github.io/2022/02/18/%EC%9D%98%EB%8F%84%EB%A5%BC-%EB%93%9C%EB%9F%AC%EB%82%B4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4"/>
   <updated>2022-02-18T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/18/의도를-드러내는-인터페이스</id>
   <content type="html">&lt;p&gt;메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다. 그건 수신 객체의 책임이다. 객체 외부에서 해당 객체의상태를 기반으로 결정을 내리는 것은 캡슐화 위반이다.&lt;/p&gt;

&lt;p&gt;객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다. 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다. 그럼으로써 응집도가 높은 클래스를 얻을 확률이 높아진다.&lt;/p&gt;

&lt;p&gt;만약 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해야 한다. 내부 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 해당 객체가 책임져야 하는 어떤 행동이 외부로 누수된 것이다.&lt;/p&gt;

&lt;p&gt;상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시킬 수 있다. 하지만 단순히 묻지 않고 시킨다고 해결되는 것은 아니다. 훌륭한 인터페이스를 만들기 위해서는 객체가 어떻게 작업을 수행하는지 노출해서는 안 된다. 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지 서술해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;의도를-드러내는-인터페이스&quot;&gt;의도를 드러내는 인터페이스&lt;/h2&gt;

&lt;p&gt;켄트 백은 Smalltalk best practice pattern에서 메서드를 명명하는 두 가지 방법을 설명한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메서드가 작업을 어떻게 수행하는지 나타내도록 이름 짓는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 경우 메서드 이름은 배구 구현 방법을 드러낸다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PeriodCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedByPeriod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SequenceCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBySequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 스타일은 좋지 않다. 이유는 두 가지다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메서드에 대해 제대로 커뮤니케이션 하지 못함. 클라이언트의 완점에서 위 두 메서드는 동일한 작업을 수행하는 메서드임. 그런데 이름이 다르기 떄문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알기 어려움.&lt;/li&gt;
  &lt;li&gt;더 큰 문제는 캡슐화를 위반한다는 것임. 이 메서드들은 클라이언트가 협력하는 객체의 종류를 알도록 강요한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PeriodCondition&lt;/code&gt; 을 사용하는 코드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SequenceCondition&lt;/code&gt; 을 사용하도록 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야 함. 만약 할인 여부를 판단하는 방법이 변경되었다면 메서드 이름 역시 변경해야 함. 메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이어트 코드도 함께 변경해야 한다는 것을 의미함. 따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫 번째 방법은 좋은 방법이 아니다. 두 번째 방법은 ‘어떻게’가 아니라 ‘무엇’에 초점을 맞춘다. 메서드의 구현이 한 가지인 경우에는 무엇을 하는지 드러내는 이름을 짓는 것이 어려울 수 있다. 하지만 무엇을 하는지 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐 아니라 유연한 코드를 만든다.&lt;/p&gt;

&lt;p&gt;무엇을 하는지 드러내는 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 대해 고민해야 한다. 이건 외부 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만든다. 결과적으로 클라언트 의도에 부합하도록 메서드 이름을 짓게 된다.&lt;/p&gt;

&lt;p&gt;위에서 예로 든 메서드를 무엇을 하는지 드러내도록 이름 짓는 방식으로 변경하면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PeriodCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SequenceCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변경된 코드는 두 클래스의 메서드가 동일한 목적을 가진다는 것을 메서드 이름을 통해 명확하게 표현한다. 클라이언트 입장에서 두 메서드는 동일한 메시지를 서로 다른 방법으로 처리하기 때문에 서로 대체 가능하다.&lt;/p&gt;

&lt;p&gt;이제 이 두 메서드를 동일한 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다. 간단하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 이라는 인터페이스를 정의하고 이 인터페이스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isSatisfiedBy&lt;/code&gt; 오퍼레이션을 정의하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PeriodCondition&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SequenceCondition&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 의 구현체가 되면 된다.&lt;/p&gt;

&lt;p&gt;메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 따라 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드를 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.&lt;/p&gt;

&lt;p&gt;이처럼 어떻게가 아니라 무엇을 하느냐에 따라 메서드 이름을 짓는 패턴을 의도를 드러내는 선택자(Intention Revealing Selector)라고 부른다.&lt;/p&gt;

&lt;도메인 주도=&quot;&quot; 설계=&quot;&quot;&gt;를 쓴 에릭 에반스는 켄트 백의 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 **의도를 드러내는 인터페이스**를 제시했다. 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만 표현해야 한다는 것이다.

오퍼레이션 이름은 협력이라는 문맥을 반영해야 한다. 클라이언트가 객체에게 ‘무엇'을 원하는지 의도를 드러내야 한다. 다시 말해 객체 자신이 아닌, 클라이언트의 의도를 표현하는 이름을 가져야 한다.
&lt;/도메인&gt;
</content>
 </entry>
 
 <entry>
   <title>디미터 법칙</title>
   <link href="https://cocodori.github.io/2022/02/17/%EB%94%94%EB%AF%B8%ED%84%B0-%EB%B2%95%EC%B9%99"/>
   <updated>2022-02-17T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/17/디미터-법칙</id>
   <content type="html">&lt;h1 id=&quot;오브젝트-6장에-소개된-원칙---디미터-법칙&quot;&gt;오브젝트 6장에 소개된 원칙 - 디미터 법칙&lt;/h1&gt;

&lt;p&gt;좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스다.&lt;/p&gt;

&lt;p&gt;책임 주도 설계 방법을 따르는 것이 좋은 인터페이스를 설계하는 좋은 방법이다.&lt;/p&gt;

&lt;p&gt;책임 주도 설계는 먼저 메시지를 선택하고, 그 다음 메시지를 처리할 객체를 결정한다. 이렇게 함으로써 협력과 무관한 오퍼레이션이 인터페이스에 스미는 것을 방지한다.&lt;/p&gt;

&lt;p&gt;퍼블릭 인터페이스 품질에 영향을 미치는 원칙 몇 가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;디미터 법칙&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;묻지 말고 시켜라&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;의도를 드러내는 인터페이스&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령-쿼리 분리&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 코드는 책(오브젝트) 이전 장에서 살펴봤던 코드임&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReservationAgency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reservation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reserve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audienceCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMovie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

			&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDiscountConditions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;discountable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreened&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDayOfWeek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDayOfWeek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
					&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStartTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreended&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLocalTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
					&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEndTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreened&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLocalTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;	
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;discountable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discountable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드의 가장 큰 단점은 인자로 전달된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 사이의 결합도가 너무 높기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 의 내부 구현을 변경할 때마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt; 도 함께 변경된다. 문제의 원인은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 뿐만 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Movie&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 에도 직접 접근하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/object0604.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 디미터 법칙(Law of demeter)이다. 디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.&lt;/p&gt;

&lt;p&gt;Java 또는 C#처럼 도트(.)로 메시지 전송을 표현하는 언어에서는 ‘오직 하나의 도트만 사용하라’는 말로 요약되기도 한다.&lt;/p&gt;

&lt;p&gt;디미터 법칙은 간단하다. 예를 들어  A라는 클래스에 구현된 모든 메서드를 m이라고 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m의 인자로 전달된 클래스(자기 자신인 A를 포함)&lt;/li&gt;
  &lt;li&gt;A의 인스턴스 변수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 이해할 수도 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this 객체&lt;/li&gt;
  &lt;li&gt;메서드의 매개변수&lt;/li&gt;
  &lt;li&gt;this의 속성&lt;/li&gt;
  &lt;li&gt;this의 속성인 컬렉션 요소&lt;/li&gt;
  &lt;li&gt;메서드 내에 생성된 지역 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이건 지난 4장에서 결합 문제를 해결하기 위해 수정한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReservationAgency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reservation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reserve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audienceCount&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Reservation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audience&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt; 는 메서드 인자로 전달된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 인스턴스에게만 메시지를 전송한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReservationAgency&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 내부에 대한 어떤 정보도 알지 못한다. 이렇게 서로 결합되어 있지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Screening&lt;/code&gt; 의 내부 구현을 변경할 때 함께 변경해야 할 이유가 없다.&lt;/p&gt;

&lt;p&gt;디미터 법칙을 적용하면 아래와 같은 구조가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/object0605.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;디미터 법칙과 캡슐화
디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. &lt;strong&gt;디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야 하는 구체적인 지침을 제공하기 때문&lt;/strong&gt;이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;다음은 디미터 법칙을 위반하는 코드의 전형적인 모습이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMovie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDiscountConditions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;메시지 전송자가 수신자의 내부 구조에 대해 물어보고, 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다. 이와 같은 코드를 기차 충돌(train wreck)이라고 부른다. 여러 대 기차가 한 줄로 늘어서 충돌한 것처럼 보이기 때문.&lt;/p&gt;

&lt;p&gt;이런 식으로 타고 타고 들어가는 방식은 수신 객체 내부 구현에 대해 자세히 알게 되는 것이고, 이 말은 두 객체의 관계가 강하게 결합된다는 뜻이다.&lt;/p&gt;

&lt;p&gt;디미터 법칙을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 관해 묻지 않게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;audienceCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디미터 법칙은 객체가 자율적인 존재여야 한다는 사실을 강조한다. 정보를 처리하는 데 필요한 책임을 정보를 알고 있는 객체에게 할당하기 때문에 응집도가 높은 객체가 만들어진다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;strong&gt;무비판적으로 디미터 법칙을 수요하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>오브젝트 6장 메시지와 인터페이스01</title>
   <link href="https://cocodori.github.io/2022/02/16/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-06%EC%9E%A5-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A401"/>
   <updated>2022-02-16T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/16/오브젝트-06장-메시지와-인터페이스01</id>
   <content type="html">&lt;h2 id=&quot;클라이언트-서버-모델&quot;&gt;클라이언트-서버 모델&lt;/h2&gt;

&lt;p&gt;협력은 어떤 객체가 다른 객체에게 무언가 요청할 때 시작된다. &lt;strong&gt;메시지는 객체 사이의 협력을 가능하게 하는 매개체&lt;/strong&gt;다. &lt;strong&gt;객체가 다른 객체에 접근할 수 있는 유일한 방법은 메시지를 전송&lt;/strong&gt;하는 것뿐. 객체는 희망하는 일을 메시지라는 형태로 전송하고, 수신 객체는 요청을 적절히 처리한 뒤에 응답한다.&lt;/p&gt;

&lt;p&gt;이 메시지를 매개로하는 &lt;strong&gt;요청과 응답의 조합이 두 객체 사이의 협력&lt;/strong&gt;을 구성한다.&lt;/p&gt;

&lt;p&gt;두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.&lt;/p&gt;

&lt;p&gt;협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다. 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.&lt;/p&gt;

&lt;p&gt;영화 예매 시스템이 있다면 이런 협력 관계를 가질 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/object0601.png&quot; alt=&quot;object0601&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Screening은 클라이언트, Movie는 서버 역할을 수행한다. 메시지를 전송하고, 응답함으로서 객체 간 협력을 만들어낸다.&lt;/p&gt;

&lt;p&gt;Movie가 최종 예매 요금을 계산하기 위해서 할인 요금이 필요하지만, Movie에는 할인 요금을 계산하기 위해 필요한 정보가 부족하다. 따라서 Movie는 할인 요금을 계산하라는 메시지를 DiscountPolicy의 인스턴스에 전송해서 할인 요금을 반환 받는다. 여기서 Movie는 클라이언트가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/object0602.png&quot; alt=&quot;object0602&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Movie의 예에서 알 수 있는 것처럼 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행한다. 협력의 관점에서 두 가지 종류의 메시지 집합으로 구성된다. 하나는 객체가 수신하는 메시지의 집합이고, 다른 하나는 외부의 객체에게 전송하는 메시지의 집합이다. 대부분 사람들은 &lt;strong&gt;객체가 수신하는 메시지 집합에만 초점을 맞추지만, 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지 집합도 함께 고려하는 것이 바람직하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;요점은 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해얗 ㅏㄴ다는 것.&lt;/p&gt;

&lt;p&gt;그리고 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 메시지라는 것.&lt;/p&gt;

&lt;h2 id=&quot;메시지와-메시지-전송&quot;&gt;메시지와 메시지 전송&lt;/h2&gt;

&lt;p&gt;메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단.&lt;/p&gt;

&lt;p&gt;한 객체가 다른 객체에게 요청하는 것을 메시지 전송 또는 메시지 패싱이라고 한다.&lt;/p&gt;

&lt;p&gt;이때 메시지를 전송하는 객체를 메시지 전송자sender라고 부르고 수신 객체를 메시지 수신자receiver라고 부른다. 클라이언트-서버 모델 관점에서는 클라이언트, 서버라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;메시지는 오퍼레이션ㅁ명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. 따라서 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합이다.&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;//condition: 수신자&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//isSatisfied: 오퍼레이션 이름&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//screening: 인자&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메시지와-메서드&quot;&gt;메시지와 메서드&lt;/h2&gt;

&lt;p&gt;메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition.isSatisfiedBy(screening)&lt;/code&gt; 이라는 메시지 전송 구문에서 메시지 수신자인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 이라는 인터페이스 타입으로 정의돼 있지만, 실제로 실행되는 코드는 인터페이스를 실체화한 클래스의 종류에 따라 달라진다.&lt;/p&gt;

&lt;p&gt;이처럼 &lt;strong&gt;메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.&lt;/strong&gt; 중요한 것은 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;객체지향은 메시지 전송과 메서드 호출을 명확하게 구분한다.&lt;/p&gt;

&lt;p&gt;메시지 전송을 코드 상에 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다. 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고, 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿어야 한다.&lt;/p&gt;

&lt;p&gt;메시지와 메서드 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다. 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다. 수신자가 어떤 클래스의 인스턴스인지, 어떤 방식으로 요청을 처리하는지 모르더라도 협력이 가능하다. 수신자 역시 누가 메시지를 전송하는지는 알 필요 없다. 단지 메시지가 도착했다는 사실만 알면 된다.&lt;/p&gt;

&lt;h2 id=&quot;퍼블릭-인터페이스와-오퍼레이션&quot;&gt;퍼블릭 인터페이스와 오퍼레이션&lt;/h2&gt;

&lt;p&gt;객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다. 외부에서 볼 때 객체 안쪽은 검은 장막으로 가려진 미지의 영역이다. 외부 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다. 이처럼 객체가 의사소통을 위해서 외부에 공개하는 메시지의 집합을 &lt;strong&gt;퍼블릭 인터페이스&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다. &lt;strong&gt;오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화&lt;/strong&gt;다. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가르키는 경우가 대부분이다. 앞에서 예로 든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 인터페이스에 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isSatisfiedBy&lt;/code&gt; 가 오퍼레이션에 해당한다.&lt;/p&gt;

&lt;p&gt;그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SequenceCondition&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PeriodCondition&lt;/code&gt; 의 두 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountCondition&lt;/code&gt; 인터페이스에 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isSatisfiedBy&lt;/code&gt; 오퍼레이션의 여러 가능한 구현 중 하나다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어 관점에서 객체가 다른 객체에게 메시지를 전송한다면 런타임시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다. 따라서 &lt;strong&gt;퍼블릭 인터페이스와 메시지 관점에서 보면 ‘메서드 호출’보다 ‘오퍼레이션 호출’이라는 용어를 사용하는 것이 더 적절하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/object0603.png&quot; alt=&quot;object0603&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;시그니처&quot;&gt;시그니처&lt;/h2&gt;

&lt;p&gt;오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만 정의한 것이다. 메서드는 이 시그니처에 구현을 더한 것이다. 일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;메시지
    &lt;ul&gt;
      &lt;li&gt;객체가 다른 객체와 협력하기 위해 사용하는 의사소통 매커니즘. 오퍼레이션이 실행되도록 요청하는 것을 메시지 전송이라고 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오퍼레이션
    &lt;ul&gt;
      &lt;li&gt;객체가 다른 객체에게 제공하는 추상적인 서비스. 오퍼레이션은 수신하는 객체의 인터페이스를 강조한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메서드
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션의 구현체. 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;퍼블릭 인터페이스
    &lt;ul&gt;
      &lt;li&gt;객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메세지의 묶음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시그니처
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션이나 메서드의 명세.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Graph</title>
   <link href="https://cocodori.github.io/2022/02/12/graph"/>
   <updated>2022-02-12T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/12/Graph</id>
   <content type="html">&lt;h1 id=&quot;graph&quot;&gt;Graph&lt;/h1&gt;

&lt;p&gt;그래프는 vertex와 edge로 이루어진 자료구조다.
vertex간 관계를 표현하는 조직도라고 볼 수 있다. 이런 점에서 Tree는 일종의 Graph다.&lt;/p&gt;

&lt;p&gt;하지만 Graph는 Tree와 달리 vertex마다 edge가 있을 수도 있고, 없을 수도 있다. 루트 노드와 부모 자식이라는 개념이 존재하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graph와 Tree&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Graph&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Tree&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;정의&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;node와 그 node를 연결하는 간선edge을 하나로 모아놓은 자료구조&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Graph의 한 종류. DAG(Directed Acyclic Graph, 방향성이 있는 비순환 그래프)의 한 종류&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;방향성&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;방향 그래프, 무방향 그래프 모두 존재&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;방향 그래프&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;사이클&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;사이클 가능. 자체 간선self-loop도 가능. 순환 그래프cycle, 비순환 그래프acyclic 모두 존재.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;사이클 불가능. self-loop도 불가능. 비순환 그래프&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;루트 노트&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;루트 노드의 개념이 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;한 개의 루트 노드만 존재. 한 개의 노드만 존재. 모든 자식 노드는 한 개의 부모 노드만을 가짐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;네트워크 모델&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;계층 모델&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;순회&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BFS, DFS&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DFS, BFS안의 Pre-, In-, Post-order&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;간선 수&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;그래프에 따라 다르며 없을 수도 있음&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;N개의 노드라면 N-1개&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;경로&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;임의의 두 노드 간의 경로는 유일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;예시 및 종류&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;지도, 지하철 노선도의 최단 경로, 전기 회로의 소자, 도로&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;이진 트리, 이진 탐색 트리, 균형 트리, 이진 힙 등&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;오일러 경로(Eulerian tour):&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;그래프에 존재하는 모든 간선edge을 한 번만 통과하면 처음 정점vertex으로 돌아오는 경로를 말한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그래프의 모든 정점에연결된 간선의 갯수가 짝수일 때만 오일러 경로가 존재한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;graph-용어&quot;&gt;Graph 용어&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;정점(vertex): 위치라는 개념. node라고도 부름.&lt;/li&gt;
  &lt;li&gt;간선(edge): 위치 간의 관계. 즉, 노드를 연결하는 선. link/branch라고도 부름.&lt;/li&gt;
  &lt;li&gt;인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점&lt;/li&gt;
  &lt;li&gt;정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수.&lt;/li&gt;
  &lt;li&gt;진입 차수(in-degree): 방향 그래프에 외부에서 오는 간선의 수&lt;/li&gt;
  &lt;li&gt;진출 차수(out-degree): 방향 그래프에서 외부로 향하는 간선의 수&lt;/li&gt;
  &lt;li&gt;경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수&lt;/li&gt;
  &lt;li&gt;단순 경로(simple path): 경로 중에서 반복되는 정점이 없을 경우&lt;/li&gt;
  &lt;li&gt;사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;graph-특징&quot;&gt;Graph 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;그래프는 네트워크 모델임.&lt;/li&gt;
  &lt;li&gt;2개 이상의 ㄱ여로가 가능.&lt;/li&gt;
  &lt;li&gt;self-loop뿐 아니라 loop/circuit도 가능&lt;/li&gt;
  &lt;li&gt;루트 노드 개념 없음&lt;/li&gt;
  &lt;li&gt;부모-자식 관계 개념 없음&lt;/li&gt;
  &lt;li&gt;순회는 DFS 또는 BFS&lt;/li&gt;
  &lt;li&gt;그래프는 cycle or acyclic이 있음&lt;/li&gt;
  &lt;li&gt;그래프는 크게 방향 그래프와 무방향 그래프가 있음.&lt;/li&gt;
  &lt;li&gt;간선의 유무는 그래프에 따라 다름.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;graph의-종류&quot;&gt;Graph의 종류&lt;/h2&gt;
&lt;h3 id=&quot;무방향-그래프-vs-방향-그래프&quot;&gt;무방향 그래프 vs. 방향 그래프&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프Undirected Graph
    &lt;ul&gt;
      &lt;li&gt;무방향 그래프의 간선은 간선을 통해서만 양방향으로 갈 수 있다.&lt;/li&gt;
      &lt;li&gt;정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현한다.
  	- (A, B)는 (B, A)와 동일하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방향 그래프Directed Graph
    &lt;ul&gt;
      &lt;li&gt;간선에 방향성이 존재하는 그래프&lt;/li&gt;
      &lt;li&gt;A -&amp;gt; B로만 갈 수 있는 간선은 &amp;lt;A,B&amp;gt;로 표시한다.
  	- &amp;lt;A,B&amp;gt;는 &amp;lt;B,A&amp;gt;와 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가중치-그래프&quot;&gt;가중치 그래프&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가중치 그래프Weighted Graph
    &lt;ul&gt;
      &lt;li&gt;간선에 비용이나 가중치가 할당된 그래프&lt;/li&gt;
      &lt;li&gt;네트워크라고도 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연결-그래프-vs-비연결-그래프&quot;&gt;연결 그래프 VS. 비연결 그래프&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연결 그래프Connected Graph
    &lt;ul&gt;
      &lt;li&gt;무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비연결 그래프Disconnected Graph
    &lt;ul&gt;
      &lt;li&gt;무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사이클-vs-비순환-그래프&quot;&gt;사이클 VS. 비순환 그래프&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Cycle
    &lt;ul&gt;
      &lt;li&gt;단순 경로simple path의 시작과 종료 정점이 동일한 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Acylic graph
    &lt;ul&gt;
      &lt;li&gt;사이클이 없는 그래프&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완전-그래프&quot;&gt;완전 그래프&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;완전 그래프Completed Graph
    &lt;ul&gt;
      &lt;li&gt;그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프&lt;/li&gt;
      &lt;li&gt;무방향 완전 그래프&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래프-구현-두-가지&quot;&gt;그래프 구현 두 가지&lt;/h2&gt;

&lt;h3 id=&quot;1인접-리스트adjaceny-list&quot;&gt;1.인접 리스트(Adjaceny List)&lt;/h3&gt;
&lt;p&gt;인접 리스트로 그래프를 표현하는 것이 가장 일반적인 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 노드를 인접 리스트에 저장한다. 즉, 각각 노드에 인접한 노드들을 리스트로 표시한다.
    &lt;ul&gt;
      &lt;li&gt;배열과 배일의 각 인덱스마다 존재하는 또다른 리스트, 연결리스트를 이용해서 인접 리스트를 표현.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  0: 1
  1: 2
  2: 0, 3
  3: 2
  4: 6
  5: 4
  6: 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;노드의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 노드 리스트에 쉽게 접근할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프에서 (a,b) 간선은 두 번 저장된다.
    &lt;ul&gt;
      &lt;li&gt;한 번은 a 노드에 인접한 간선을 저장하고, 다른 한 번은 b에 인접한 간선을 저장한다.&lt;/li&gt;
      &lt;li&gt;노드의 수: N, 간선의 수: E인 무방향 그래프의 경우 N개의 리스트, N개의 배열, 2E개의 노드가 필요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트리에선 특정 노드 하나(루트 노드)에서 다른 모든 노드로 접근이 가능하다.&lt;/li&gt;
  &lt;li&gt;그래프에서는 특정 노드에서 다른 모드로 접근이 가능하지는 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Graph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;인접-행렬adjacency-matrix&quot;&gt;인접 행렬(Adjacency Matrix)&lt;/h2&gt;
&lt;p&gt;인접 행렬은 NxN 불린 행렬(Boolean Matrix)로, matrix[i][j]가 true라면 i -&amp;gt; j로 간선이 있다는 뜻이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0과 1을 이용한 정수 매트릭스를 사용할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;간선&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;가&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;그래프에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;존재&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;노드의 개수가 N인 그래프를 인접 행렬로 표현
    &lt;ul&gt;
      &lt;li&gt;간선의 수와 무관하게 항상 n^2개의 메모리 공간이 필요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프를 인접 행렬로 표현한다면, 이 행렬은 대칭 행렬Symmetric Matrix이 된다.
    &lt;ul&gt;
      &lt;li&gt;물론 방향 그래프는 대칭 행렬이 안될 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 리스트를 사용한 그래프 알고리즘들 또한 인접 행렬에서도 사용이 가능하다.
    &lt;ul&gt;
      &lt;li&gt;하지만 인접 행렬은 효율성이 떨어진다.&lt;/li&gt;
      &lt;li&gt;인접 리스트는 어떤 노드에 인접한 노드를 쉽게 찾을 수 있지만, 인접 행렬에서는 인접한 노드를 찾기 위해 모든 노드를 순회해야 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인접-리스트와-인접-행렬-중-선택-방법&quot;&gt;인접 리스트와 인접 행렬 중 선택 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인접 리스트
    &lt;ul&gt;
      &lt;li&gt;그래프 내 적은 숫자 간선만을 가지는 희소 그래프(Sparse Graph)의 경우&lt;/li&gt;
      &lt;li&gt;장점
  	- 어떤 노드에 인접한 노드를 쉽게 찾을 수 있다.
        &lt;ul&gt;
          &lt;li&gt;그래프에 존재하는 모든 간선의 수는 O(N+E)안에 알 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
  	- 간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 차수, 즉 정점 차수만큼 시간이 필요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인접 행렬
    &lt;ul&gt;
      &lt;li&gt;그래프에 간선이 많이 존재하는 밀집 그래프Dense Graph의 경우&lt;/li&gt;
      &lt;li&gt;장점
  	- 두 정점을 연결하는 간선의 존재 여부를(M[i][j])를 O(1) 안에 즉시 알 수 있다.
        &lt;ul&gt;
          &lt;li&gt;정점의 차수는 O(N) 안에 알 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
  	- 어떤 노드에 인접한 노드를 찾기 위해 모든 노드를 순회해야 함.
        &lt;ul&gt;
          &lt;li&gt;그래프에 존재하는 모든 간선의 수는 O(N^2) 안에 알 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래프의-탐색&quot;&gt;그래프의 탐색&lt;/h2&gt;

&lt;h3 id=&quot;1-깊이-우선-탐색dfs-depth-first-search&quot;&gt;1. 깊이 우선 탐색(DFS, Depth-First Search)&lt;/h3&gt;

&lt;p&gt;루트 노드 혹은 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;즉 넓게 탐색하기 전에 깊게 탐색하는 것.&lt;/li&gt;
  &lt;li&gt;사용하는 경우: 모든 노드를 방문하고자 하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-너비-우선-탐색bfs-breadth-first-search&quot;&gt;2. 너비 우선 탐색(BFS, Breadth-First Search)&lt;/h3&gt;
&lt;p&gt;루트 노드 혹은 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;깊게 탐색하기 전에 넓게 탐색하는 것&lt;/li&gt;
  &lt;li&gt;사용하는 경우: 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 사용.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고:
https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Rust Hello world</title>
   <link href="https://cocodori.github.io/2022/02/11/rust-hello-world"/>
   <updated>2022-02-11T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/11/Rust-Hello-world</id>
   <content type="html">&lt;p&gt;Rust는 웹 서버, 메일 서버, 브라우저, 네트워크 소프트웨어 등에 사용한다. 컴파일러 및 인터프리터, 가상화 및 소프트웨어 컨테이너, DB, OS, 암호화에도 사용한다. 임베디드 디바이스용 게임, CLI프로그램, 웹 어셈블리, 애프리케이션을 빌드하는 데도 Rust를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;Rust는 C, C++같은 언어를 대체할 수 있다. 마찬가지로 최신 언어와 달리 대규모 런타임, 또는 가비지 컬렉터가 없다. 그러나 메모리 안전성을 보장한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rust를 사용할 때 이점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형식 안전: 컴파일러는 잘못된 형식의 변수에 어떤 작업도 적용되지 않게 보장한다.&lt;/li&gt;
  &lt;li&gt;메모리 안전: Rust포인터는 항상 유효한 메모리를 참조한다.&lt;/li&gt;
  &lt;li&gt;데이터 경합 없음: Rust의 바로우 검사기는 프로그램의 여러 부분이 동일한 값을 동시에 변경할 수 없도록 하여 스레드 안전하다.&lt;/li&gt;
  &lt;li&gt;무비용 추출: Rust를 사용하면 최소한의 성능 비용으로, 또는 성능 비용 없이 반복, 인터페이스, 함수 프로그래밍 같은 상위 수준의 개념을 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;최소 런타임: rust에는 최소한의 선택적 런타임이 있다. 메모리를 효율적으로 관리할 수 있도록 이 언어에는 GC도 없다. 이런 측면에서 C와 C++과 유사하다.&lt;/li&gt;
  &lt;li&gt;OS미설치 대상: Rust는 임베디드 및 운영체제 미설치 프로그래밍을 대상으로 지정하여 운영체제 커널 또는 디바이스 드라이버 작성에 적합하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rust-고유-기능&quot;&gt;Rust 고유 기능&lt;/h2&gt;

&lt;p&gt;프로그래밍 언어가 프로젝트에 적합한지 판단하려면, 기능 및 제한 사항에 대해 알아야 한다.&lt;/p&gt;

&lt;h3 id=&quot;rust-크레이트-및-라이브러리-사용&quot;&gt;Rust 크레이트 및 라이브러리 사용&lt;/h3&gt;

&lt;p&gt;Rust 표준 라이브러리 std에서는 Rust 프로그램의 기본 정의 및 작업에 사용할 수 있는 코드가 포함되어 있다. 이 라이브러리에는 String및 Vec&lt;T&gt;와 같은 핵심 데이터형식, Rust 기본 형식에 대한 작업, 일반적으로 사용되는 매크로 함수를 위한 코드, 입력 및 출력 작업에 대한 지원, 기타 여러 기능 영역이 포함되어 있다.&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;Rust 프로그램에서 사용할 수 있는 수만 개의 라이브러리와 타사 크레이트를 사용할 수 있으며, 대부분의 경우 Rust의 타사 크레이트 리포지토리인 &lt;a href=&quot;http://crates.io&quot;&gt;crates.io&lt;/a&gt; 를 통해 액세스 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;std - Rust 표준 라이브러리.
    &lt;ul&gt;
      &lt;li&gt;std:: collections - HashMap 등 컬렉션 형식에 대한 정의&lt;/li&gt;
      &lt;li&gt;std:: env - 사용자 환경으로 작업하기 위한 함수&lt;/li&gt;
      &lt;li&gt;std:: fmt - 출력 형식을 제어하는 기능&lt;/li&gt;
      &lt;li&gt;std:: fs - 파일 시스템을 사용하기 위한 함수&lt;/li&gt;
      &lt;li&gt;std:: io - 입/출력 작업을 위한 정의 및 기능&lt;/li&gt;
      &lt;li&gt;std:: path - 파일 시스템 경로 데이터 작업을 지원하는 정의 및 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;structopt - 명령줄 인수를 쉽게 구문 분석하기 위한 타사 크레이트&lt;/li&gt;
  &lt;li&gt;chrono - 날짜 및 시간 데이터를 처리하는 타사 크레이트&lt;/li&gt;
  &lt;li&gt;regex - 정규식을 사용하는 타사 크레이트&lt;/li&gt;
  &lt;li&gt;serde - Rust 데이터 구조에 대한 Serialization 및 Deserialization 작업의 타사 크레이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적으로 std 라이브러리는 모든 Rust에서 사용할 수 있다. 크레이트 또는 라이브러리에서 재사용 가능한 코드에 액세스하기 위해 use 키워드를 구현한다. use 키워드를 사용하는 프로그램의 정의 및 함수에 액세스할 수 있도록 크레이트 또는 라이브러리의 코드가 ‘범위로 전환’된다. 표준 라이브러리는 use std::fmt 에서와 같이 std경로를 사용하여 use문에 액세스 할 수 있다. 다른 크레이트나 라이브러리에는 use regex::Regex과 같이 이름을 사용하여 액세스 한다.&lt;/p&gt;

&lt;h3 id=&quot;cargo를-사용하여-프로젝트-생성-및-관리&quot;&gt;Cargo를 사용하여 프로젝트 생성 및 관리&lt;/h3&gt;

&lt;p&gt;Rust 컴파일러(rustc)를 사용하여 크레이트를 직접 만들 수 있다. 하지만 대부분 프로젝트는 Rust 빌드 도구와 Cargo라는 종속성 관리자를 사용한다.&lt;/p&gt;

&lt;p&gt;Cargo는 다음을 비롯한 많은 작업을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cargo new  명령을 사용하여 새 프로젝트 템플릿을 만든다.&lt;/li&gt;
  &lt;li&gt;cargo build 명령을 사용하여 프로젝트를 빌드한다.&lt;/li&gt;
  &lt;li&gt;cargo run 명령을 사용하여 프로젝트를 빌드하고 실행한다.&lt;/li&gt;
  &lt;li&gt;cargo test 명령을 사용하여 프로젝트를 테스트한다.&lt;/li&gt;
  &lt;li&gt;cargo check 프로젝트에 대한 설명을 작성한다.&lt;/li&gt;
  &lt;li&gt;cargo doc 명령을 사용하여 crates.io에 라이브러리를 게시한다.&lt;/li&gt;
  &lt;li&gt;크레이트 이름을 Cargo.html 파일에 추가하여 프로젝트에 종속 파일을 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rust는-언제-사용하나&quot;&gt;Rust는 언제 사용하나?&lt;/h3&gt;

&lt;p&gt;Rust 언어에는 프로젝트에 가장 적합한 언어를 선택할 때 고려해야 하는 몇 가지 장점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rust를 사용하면 C 및 C++와 같은 언어로 작성된 프로그램 및 라이브러리의 성능 및 리소스 사용을 제어하면서, 기본적으로 메모리 안전 상태에서 일반적인 버그의 전체 클래스를 제거할 수 있다.&lt;/li&gt;
  &lt;li&gt;Rust에는 개발자가 규칙 또는 설명서에 의존하지 않고 프로그램의 다양한 고정 요소를 컴파일러가 확인하는 코드로 인코딩할 수 있는 다양한 추상화 기능이 있다. 이 기능으로 컴파일하면 작동하는 느낌을 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;Rust에는 코드를 빌드, 테스트, 문서화 및 공유하기 위한 기본 제공 도구와 타사 도구 및 라이브러리의 풍부한 에코시스템이 포함되어 있다. 이런 도구를 사용하면 일부 언어에서는 일부작업을 Rust에서 쉽고 생산적으로 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Hello World&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;print 문에 !가 붙는 게 좀 신기.&lt;/p&gt;

&lt;p&gt;참고:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/learn/paths/rust-first-steps/&quot;&gt;Rust로 첫 번째 단계 수행 - Learn&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Common Batch Pattern</title>
   <link href="https://cocodori.github.io/2022/02/10/spring-batch-common-pattern"/>
   <updated>2022-02-10T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/10/Spring-Batch-Common-Pattern</id>
   <content type="html">&lt;h1 id=&quot;common-batch-pattern&quot;&gt;Common Batch Pattern&lt;/h1&gt;

&lt;p&gt;일부 배치 job은 스프링 배치가 제공하는 컴포넌트 만으로 구성할 수 있다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReader&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemWriter&lt;/code&gt; 구현체만으로 다양한 시나리오를 구현할 수 있다. 하지만 커스텀 코드가 필요할 때가 훨씬 많다. 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tasklet&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReader&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemWriter&lt;/code&gt; 와 다양한 리스너 인터페이스를 구현하는 것부터 시작한다. 제일 간단한 배치는 스프링 배치의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReader&lt;/code&gt; 를 사용하면 되지만 아이템을 가공하고 write할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemWriter&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemProcessor&lt;/code&gt; 를 커스텀 해야 할 때가 많다.&lt;/p&gt;

&lt;p&gt;커스텀 비즈니스 로직에서 흔히 쓰이는 몇 가지 패턴이 있다. 예제는 주로 리스너 인터페이스를 사용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReader&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemWriter&lt;/code&gt; 는 필요하다면 리스너 인터페이스도 구현할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;logging-item-processing-and-failures&quot;&gt;Logging ITem Processing and Failures&lt;/h2&gt;

&lt;p&gt;step에서 에러가 발생하면 아이템별로 특정 채널에 로그를 남기거나 데이터베이스에 레코드를 넣는 식의 특별한 처리를 많이 한다. 청크 지향 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step&lt;/code&gt; 을 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt; 메소드에서 생긴 에러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReadListener&lt;/code&gt; 로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 메소드에서 생긴 에러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemWriteListener&lt;/code&gt; 로 쉽게 구현할 수 있다. 아래 예제에 있는 리스너는 read와 write 실패를 모두 로깅한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemFailureLoggerListener&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemListenerSupport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Log&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LogFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;item.error&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onReadError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Encountered error on read&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onWriteError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Encountered error on write&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스너를 구현했다면 아래 예제처럼 step에 등록해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Step&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;simpleStep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stepBuilderFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;simpleStep&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
									&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
									&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemFailureLoggerListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
									&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;리스너가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError()&lt;/code&gt; 메소드 안에서 처리하는 일은 트랜잭션 안에 있어야 롤백할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onError()&lt;/code&gt; 안에서 데이터베이스 같은 트랜잭션 리소스를 사용한다면 메소드에 선언적인 트랜잭션을 추가해서 전파(propagation) 속성을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REQUIRES_NEW&lt;/code&gt; 로 설정해야 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;stopping-a-job-manually-for-business-reasons&quot;&gt;Stopping a Job Manually for Business Reasons&lt;/h2&gt;

&lt;p&gt;스프링 배치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JobLauncher&lt;/code&gt; 인터페이스로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop()&lt;/code&gt; 메소드를 제공하지만 애플리케이션 개발자가 사용하는 용도는 아니다. 가끔은 비즈니스 로직 안에서 job을 중단하는 게 더 편하거나 합리적이다.&lt;/p&gt;

&lt;p&gt;가장 간단한 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RuntimeException&lt;/code&gt; 을 던지는 것이다(무한으로 재시도하거나 스킵하지 않는 exception).&lt;/p&gt;

&lt;p&gt;예를 들어 아래처럼 커스텀 exception을 사용할 수 있다:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PoisonPillItemProcessor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemProcessor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isPoisonPill&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PoisonPillException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Poison pill detected: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게  step을 종료하는 또 다른 방법은 아래 예제처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemReader&lt;/code&gt; 에서 null을 리턴하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EarlyCompletionItemReader&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setDelegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ItemReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEndItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
		
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예제는 사실 아이템이 null이면 배치가 완료된 것으로 판단하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CompletionPolicy&lt;/code&gt; 디폴트 구현체가 있어야 동작한다. 더 복잡한 completion policy를 구현했다면 아래 예제처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleStepFactoryBean&lt;/code&gt; 으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step&lt;/code&gt; 에 주입하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Step&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;simpleStep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stepBuilderFatory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;simpleStep&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;.&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpecialCompletionPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
					&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 방법은 아이템을 처리하는 동안 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step&lt;/code&gt; 구현체가 체크하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StepExecution&lt;/code&gt; 플래그를 설정하는 것이다. 이 방법을 사용하려면 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StepExecution&lt;/code&gt; 에 접근하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StepListener&lt;/code&gt; 를 구현하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step&lt;/code&gt; 에 등록해야 한다. 다음은 플래그를 설정하는 리스너 예시:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomItemWriter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemListenerSupport&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StepListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StepExecution&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stepExecution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;beforeStep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;StepExecution&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stepExecution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stepExecution&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stepExecution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterRead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isPoisonPill&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;stepExecution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setTerminateOnly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 플래그를 사용하면 디폴트 설정대로 step이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JobInterruptedException&lt;/code&gt; 을 던진다. 이 동작은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StepInterruptionPolicy&lt;/code&gt; 가 제어한다. 하지만 exception을 던지거나 던지지 않는 동작만 가능해서 항상 비정상적으로 job을 종료한다.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-footer-record&quot;&gt;Adding a Footer Record&lt;/h2&gt;

&lt;p&gt;Flat 파일에 write할 때는 모든 처리가 끝난 후에 파일 끝에 footer 레코드를 적는 경우가 종종 있다. 스프링 배치는 이를 위한 FlatFileFooterCallback 인터페이스를 지원한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FlatFileFooterCallback&lt;/code&gt; 은 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FlatFileHeaderCallback&lt;/code&gt; 도 있음) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FlatFileItemWriter&lt;/code&gt; 의 선택적인 프로퍼티이며, 아래 예제처럼 item writer에 추가할 수 있다:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FlatFileItemWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;itemWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outputResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FlatFileItemWriterBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;itemWriter&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outputResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineAggregator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineAggregator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;headerCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headerCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;footerCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;footerCallback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
						&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;footer callback 인터페이스는 꼬리말을 적을 때 호출하는 메소드 하나만 가지고 있다. 인터페이스 정으ㅣ느ㄴ 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FlatFileFooterCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeFooter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고: https://godekdls.github.io/Spring%20Batch/commonbatchpatterns/&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SpringBatch JsonItemReader</title>
   <link href="https://cocodori.github.io/2022/02/08/spring-batch-jsonitemreader"/>
   <updated>2022-02-08T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/08/Spring-Batch-JsonItemReader</id>
   <content type="html">&lt;p&gt;스프링 배치는 JSON 처리에 사용할 수 있는 ItemReader를 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt;는 JSON 청크를 읽어서 객체로 파싱한다는 면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackEventItemReader&lt;/code&gt; 동작 개념과 거의 동일하다. JSON 문서는 객체로 구성된 배열이 최상단에 하나만 존재하는 완전한 형태의 문서여야 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 가 동작할 때 실제 파싱 작업은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonObjectReader&lt;/code&gt; 인터페이스의 구현체에게 위임된다.&lt;/p&gt;

&lt;p&gt;인터페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackEventItemReader&lt;/code&gt; 에서 언마샬러가 XML을 객체로 파싱하는 것과 유사한 방법으로 실제로 JSON을 객체로 파싱하는 역할을 한다. 스프링 배치는 애플리케이션 개발에 즉시 사용할 수 있도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonObjectReader&lt;/code&gt; 인터페이스 구현체 두 개를 제공한다. 하나는 Jackson을 파싱 엔진으로 사용하며 나머지 하나는 Gson을 사용한다. 예제에서는 Jackson 구현체를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시 데이터&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Laura&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;middleInitial&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Minella&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2039 Wall Street&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;city&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Omaha&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;state&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;IL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;zipCode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;35446&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;transactions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;accountNumber&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;829433&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;transactionDate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2010-10-14 05:48:59&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;amount&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;26.08&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 를 구성하려면 스프링 배치가 제공하는 builder를 사용한다. 빌더에는 세 가지 의존성이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;batch name&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonObjectReader&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;읽을 리소스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 의 다른 구성 항목에는 입력이 반드시 존재해야 하는지 나타내는 플래그(strict.기본값 true), 상태를 저장해야 하는지를 나타내는 플래그(saveState) 현재 ItemCount가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파일을 읽어들이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@StepScope&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;customerFileReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#{jobParameters['customerFile']}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JsonItemReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;objectMapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectMapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;objectMapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateFormat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;jsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JacksonJsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;JacksonJsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setMapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objectMapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JsonItemReaderBuilder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;customerFileReader&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsonObjectReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectMapper&lt;/code&gt; 인스턴스를 생성한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectMapper&lt;/code&gt; 클래스는 Jackson이 JSON을 읽고 쓰는 데 사용하는 주요 클래스다. 애플리케이션 개발할 때 대부분 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectMapper&lt;/code&gt; 생성하는 코드를 직접 작성할 필요가 없다. 그러나 예제에서는 입력 파일의 날짜 형식을 지정해야 한다. 즉, 사용하려는 ObjectMapper를 커스터마이징 해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectMapper&lt;/code&gt; 인스턴스를 생성한다.
    &lt;ol&gt;
      &lt;li&gt;입력 파일의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transactionDate&lt;/code&gt; 를 처리할 날짜 형식을 지정한다.&lt;/li&gt;
      &lt;li&gt;이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JacksonJsonObjectReader&lt;/code&gt; 를 생성한다.
        &lt;ol&gt;
          &lt;li&gt;이때 두 가지 의존성이 필요하다.
            &lt;ol&gt;
              &lt;li&gt;반환할 클래스(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt;)&lt;/li&gt;
              &lt;li&gt;커스터마이징된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectMapper&lt;/code&gt;
                &lt;ol&gt;
                  &lt;li&gt;마지막으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 인스턴스를 구성한다.&lt;/li&gt;
                  &lt;li&gt;새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 를 생성한 뒤 이름, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonObjectReader&lt;/code&gt; 객체, 읽어들일 리소스를 구성했다. 그리고 build 메서드를 호출해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JsonItemReader&lt;/code&gt; 인스턴스를 생성한다.&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참고: 스프링 배치 완벽가이드&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Effective Kotlin Item5 예외를 활용해 코드에 제한을 걸어라</title>
   <link href="https://cocodori.github.io/2022/02/07/effective-kotlin-item5-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%BD%94%EB%93%9C%EC%97%90-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B1%B8%EC%96%B4%EB%9D%BC"/>
   <updated>2022-02-07T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/07/Effective-Kotlin-Item5-예외를-활용해-코드에-제한을-걸어라</id>
   <content type="html">&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;확실하게 어떤 형태로 동작해야 하는 코드가 있다면, 예외를 활용해 제한을 거는 게 좋다.
코틀린은 다음과 같은 방법을 사용할 수 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;require&lt;/li&gt;
  &lt;li&gt;check&lt;/li&gt;
  &lt;li&gt;assert&lt;/li&gt;
  &lt;li&gt;return or throw와 함께 사용하는 Elivs operator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Stack&amp;lt;T&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cannot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cannot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 제한을 걸면 다양한 이점이 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;문서를 읽지 않아도 문제를 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;문제가 있을 경우 함수가 예상하지 못한 동작을 하지 않고 throw한다. 이런 제한으로 인해서 문제를 놓치지 않을 수 있고 코드가 더 안정적으로 작동하게 된다.&lt;/li&gt;
  &lt;li&gt;코드가 어느 정도 자체적으로 검사된다. 이와 관련된 테스트를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;스마트 캐스트 기능을 활용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;argument&quot;&gt;Argument&lt;/h2&gt;

&lt;p&gt;함수를 정의할 때 타입 시스템을 활용해서 아규먼트에 제한을 거는 코드를 많이 사용한다.
&lt;strong&gt;몇 가지 예&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;숫자를 아규먼트로 받아서 팩토리얼을 계산한다면 숫자는 양의 정수여야 한다.&lt;/li&gt;
  &lt;li&gt;좌표를 아규먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요하다.&lt;/li&gt;
  &lt;li&gt;사용자로부터 이메일 주소를 입력받을 때는 값이 입력되어 있는지, 그리고 이메일 형식이 올바른지 확인해야 한다.
일반적으로 이런 제한을 걸 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt; 를 사용함. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt; 는 조건을 만족하지 않을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt; 발생 시킴.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n-1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findClusters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cluster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isNotEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sendEmail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;requireNotNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isValidEmail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같은 형태의 입력 유효성 검사 코드는 함수의 가장 앞부분에 배치되므로 읽는 사람도 쉽게 확인할 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt; 함수는 조건을 만족하지 못하면 무조건 throw를 발생시키기 때문에 제한을 무시할 수 없다. 그리고 다음처럼 코드 블록을 사용해서 지연 메시지를 정의할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cannot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n-1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;상태&quot;&gt;상태&lt;/h2&gt;

&lt;p&gt;어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할 때가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 객체가 미리 초기화되어 있어야만 처리를 하고 싶은 함수&lt;/li&gt;
  &lt;li&gt;사용자가 로그인 했을 때만 처리하게 하고 싶은 함수&lt;/li&gt;
  &lt;li&gt;객체를 사용할 수 있는 시점에 사용하고 싶은 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;상태와 관련된 제한을 걸 때는 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check&lt;/code&gt; 함수를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUserInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;checkNotNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check&lt;/code&gt; 함수는 지정된 예측을 만족하지 못할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IllegalStatementException&lt;/code&gt; 을 throw 한다. 상태가 올바른지 확인할 때 사용한다. 지연 메시지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt; 과 마찬가지로 코드 블록을 사용해서 변경할 수 있다. 함수 전체에 대한 어떤 예측이 있을 때는 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt;블록을 배치하고 그 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check&lt;/code&gt; 를 배치한다.
이런 확인은 사용자가 규약을 어기고 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 사용한다.&lt;/p&gt;

&lt;p&gt;스스로 구현한 내용을 확인할 때는 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 라는 또 다른 함수를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;assert&quot;&gt;Assert&lt;/h2&gt;

&lt;p&gt;함수가 올바르게 구현되었다면 확실하게 참을 낼 수 있는 코드들이 있다. 예를 들어 어떤 함수가 10개의 요소를 리턴한다면, ‘함수가 10개의 요소를 리턴하는가?’라는 코드는 참이다. 그런데 함수가 올바르게 구현되어 있지 않을 수도 있다. 처음부터 구현을 잘못했을 수도 있고, 해당 코드를 이후에 다른 누가 변경해서 제대로 동작하지 않는 것일 수도 있다. 이런 구현 문제로 발생하는 추가적인 문제를 예방하려면 단위 테스트를 사용하는 게 좋다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StackTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pops&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;correct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;’&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 스택이 10개의 요소를 pop하면 10개의 요소가 나온다는 보편적인 사실을 테스트한다.
하지만 하나의 경우만 테스트해서는 모든 상황에서 괜찮을지 알 수 없다. 따라서 모든 pop 호출 위치에서 제대로 동작하는지 확인해도 좋을 것이다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//…&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 조건은 코틀린/JVM에서만 활성화되며, -ea JVM 옵션을 활성화해야 확인할 수 있다. 이런 코드도 코드가 예상대로 동작하는지 확인하므로 테스트라고 할 수 있다. 다만 프로덕션 환경에서는 오류가 발생하지 않는다. 테스트할 때만 활성화되므로 오류가 발생해도 사용자가 알아차릴 수 없다.
만약 이 코드가 심각한 결과를 초래할 가능성이 있다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check&lt;/code&gt; 를 사용하는 게 좋다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Assert 계열 함수는 코드를 자체 점검하며 더 효율적으로 테스트할 수 있다.&lt;/li&gt;
  &lt;li&gt;특정 상황이 아닌 모든 상황에 대한 테스트를 할 수 있다.&lt;/li&gt;
  &lt;li&gt;실행 시점에 정확하게 어떻게 되는지 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;실제 코드가 더 빠른 시점에 실패하게 만든다. 따라서 예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt; : 아규먼트와 관련된 예측을 정의할 때 사용하는 범용적인 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check&lt;/code&gt; : 상태와 관련된 예측을 정의할 때 사용하는 범용적인 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; : 테스트 모드에서 테스트를 할 때 사용하는 범용적인 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;throw&lt;/code&gt; 와 함께 Elvis 연산자 사용하기&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>요약 - 한 개의 메소드만 갖는 계층형 패키지 스타일</title>
   <link href="https://cocodori.github.io/2022/02/06/%EC%9A%94%EC%95%BD-%ED%95%9C-%EA%B0%9C%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A7%8C-%EA%B0%96%EB%8A%94-%EA%B3%84%EC%B8%B5%ED%98%95-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%8A%A4%ED%83%80%EC%9D%BC"/>
   <updated>2022-02-06T00:00:00+01:00</updated>
   <id>https://cocodori.github.io/2022/02/06/요약-한-개의-메소드만-갖는-계층형-패키지-스타일</id>
   <content type="html">&lt;p&gt;방대한 서비스 클래스를 어떻게 잘 나눌 수 있을까? 고민한 적 많았는데 우연히 이 글을 읽었다. 기회가 되면 실제 프로젝트에 적용해보고 싶다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://johngrib.github.io/wiki/article/hierarchical-controller-package-structure/#fn:c-s-r-blame&quot;&gt;(기록) 한 개의 메소드만 갖는 계층형 컨트롤러/서비스 패키지 스타일 - 기계인간 John Grib&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;요약&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;한-개의-메소드만-갖는-계층형-패키지-스타일&quot;&gt;한 개의 메소드만 갖는 계층형 패키지 스타일&lt;/h1&gt;
&lt;p&gt;Java/Spring을 사용해 애플리케이션을 만들다보면 Controller-Service-Repository 패키지 안에서 영원히 헤매고 다니게 됨. 프로젝트에 익숙해지기 전에는 뭐가 어디에 있는지 알 수 없음.&lt;/p&gt;

&lt;p&gt;그래서 한 가지 실험을 했음
	* 집합의 포함관계를 강력히 의식한 계층형 구조로 패키지를 구성
	* 한 가지 용도를 암시하는 클래스 이름으로 행위와 책임을 제한(SRP)
	* 서비스/컨트롤러를 만들 때 public 메소드를 딱 한 가지만 가지도록 만듦&lt;/p&gt;

&lt;h2 id=&quot;command-query를-분리하다&quot;&gt;Command, Query를 분리하다&lt;/h2&gt;
&lt;p&gt;글쓴이가 신입일 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoardService&lt;/code&gt;  같은 걸 만들어서 모든 메소드를 쑤셔넣음.
수백 라인이 되는 매우 불안한 서비스 클래스를 생산해냈음.
그러다 연차가 좀 쌓이고 Command(등록,수정,삭제), Query(조회)로 나눔.
	* &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoardCommandService&lt;/code&gt;
	* &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoardQueryService&lt;/code&gt;
하지만 반으로 쪼개졌을 뿐 비대하고 엉망이긴 마찬가지.&lt;/p&gt;

&lt;h2 id=&quot;srp를-준수하자&quot;&gt;SRP를 준수하자.&lt;/h2&gt;
&lt;p&gt;문득 SRP를 강력하게 지킨다면 더 단순하게 만들 수 있겠다는 생각이 듦.
컴포넌트 하나가 public 메소드를 하나만 서비스하도록 설계했더니 생각보다 괜찮았음.
해당 클래스에 대한 테스트 클래스 파일도 메소드 하나만을 주제로 테스트하니 좋았음.&lt;/p&gt;

&lt;p&gt;그리고 서비스 클래스를 만들 때 에릭에반스 DDD 책을 참고해  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;***Service&lt;/code&gt; 라고 네이밍하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-er&lt;/code&gt; 로 했음.
이런 식.
	* &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoardCreator&lt;/code&gt;
	* &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CommentCreator&lt;/code&gt; 
	* &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CommentDeleter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 변경하니 방대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoardService&lt;/code&gt; 는 CRUD 오퍼레이션 단위로 촘촘하게 분리할 수 있었음.
	* 클래스 하나가 30줄을 넘는 경우가 드물다
	* 파일 열어보면 5초 안에 뭐하는 파일인지 바로 파악 가능
	* 테스트 코드 응집도 높아짐
	* 파일이 많아지긴 하나 크게 신경쓰지 않음&lt;/p&gt;

&lt;p&gt;소규모 프로젝트에 적용했고 이 프로젝트에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-Service&lt;/code&gt; 로 끝나는 클래스가 단 하나도 없었음.&lt;/p&gt;

&lt;h2 id=&quot;컨트롤러도-마찬가지로-srp를-준수하도록&quot;&gt;컨트롤러도 마찬가지로 SRP를 준수하도록&lt;/h2&gt;
&lt;p&gt;컨트롤러를 만들 때 다음과 같은 규칙을 설정함
 	* 컨트롤러 하나는 API URI 하나만 담당한다
 	* URI 경로를 그대로 패키지 경로로 사용한다
URI가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/shop/product&lt;/code&gt; 라고 할 때 패키지를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web/shop/product&lt;/code&gt; 이런 식으로 만들고 컨트롤러를 이 안에 배치.&lt;/p&gt;
</content>
 </entry>
 

</feed>
